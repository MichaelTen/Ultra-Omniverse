<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultra Omniverse · Bouncing Balls (Physics)</title>
  <meta name="description" content="Three.js + cannon-es spheres bouncing and colliding in a box." />
  <style>
    :root { --bg0:#1d2021; --fg:#ebdbb2; --accent:#d79921; --muted:#a89984; }
    html,body{height:100%;margin:0}
    body{background:radial-gradient(1200px 700px at 30% 20%, #3c3836, var(--bg0));color:var(--fg);
         font:14px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #app{position:fixed;inset:0;overflow:hidden}
    .hud{position:fixed;left:20px;top:16px;padding:10px 14px;background:rgba(40,40,40,.55);
         border:1px solid #3c3836;border-radius:12px;backdrop-filter:blur(6px)}
    .hud b{color:var(--accent)}
    a{color:var(--accent);text-decoration:none} a:hover{text-decoration:underline}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <b>Bouncing Balls</b> · Drag to orbit • Scroll to zoom • <kbd>Space</kbd> pause •
    <a href="/ultra-omniverse/">Back</a>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.164.1/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js";
    import * as CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

    // Renderer
    const app = document.getElementById("app");
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    // Scene / Camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1d2021);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(8, 6, 10);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 6);
    scene.add(dir);

    // Physics world
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.allowSleep = true;
    const defaultMat = new CANNON.Material("default");
    const contact = new CANNON.ContactMaterial(defaultMat, defaultMat, { restitution: 0.85, friction: 0.02 });
    world.addContactMaterial(contact);

    // Box bounds (size)
    const half = 6;     // half-extent of the play box
    const thick = 0.2;  // wall thickness

    // Visual box
    const boxWire = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(half*2, half*2, half*2)),
      new THREE.LineBasicMaterial({ color: 0x665c54 })
    );
    scene.add(boxWire);

    // Physics planes (floor + 5 walls)
    const walls = [
      {pos:[0,-half,0], rot:[-Math.PI/2,0,0]},          // floor
      {pos:[0, half,0], rot:[ Math.PI/2,0,0]},          // ceiling
      {pos:[ half,0,0], rot:[0,-Math.PI/2,0]},          // +X
      {pos:[-half,0,0], rot:[0, Math.PI/2,0]},          // -X
      {pos:[0,0, half], rot:[0,0,0]},                   // +Z
      {pos:[0,0,-half], rot:[0, Math.PI,0]}             // -Z
    ];
    const planeShape = new CANNON.Plane();
    walls.forEach(w=>{
      const body = new CANNON.Body({ mass: 0, material: defaultMat });
      body.addShape(planeShape);
      body.position.set(...w.pos);
      body.quaternion.setFromEuler(...w.rot, "XYZ");
      world.addBody(body);
    });

    // Balls
    const N = 40;
    const minR = 0.18, maxR = 0.45;
    const threeMeshes = [];
    const bodies = [];

    for (let i=0; i<N; i++) {
      const r = minR + Math.random()*(maxR-minR);
      const geo = new THREE.SphereGeometry(r, 24, 16);
      const mat = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(Math.random(), 0.55, 0.6),
        metalness: 0.15, roughness: 0.4
      });
      const mesh = new THREE.Mesh(geo, mat);
      scene.add(mesh);
      threeMeshes.push(mesh);

      const shape = new CANNON.Sphere(r);
      const body = new CANNON.Body({ mass: r*2, material: defaultMat, shape });
      // Random non-overlapping-ish start
      body.position.set(
        (Math.random()*2-1)*(half-1.2),
        (Math.random()*0.5+0.2)*(half-1.0),
        (Math.random()*2-1)*(half-1.2)
      );
      // Random kick
      body.velocity.set((Math.random()*6-3), (Math.random()*4+2), (Math.random()*6-3));
      world.addBody(body);
      bodies.push(body);
    }

    // Resize
    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener("resize", onResize);

    // Animate
    let paused = false;
    window.addEventListener("keydown", (e)=>{ if(e.code==="Space") paused=!paused; });

    const fixedTimeStep = 1/60;
    let last;
    function loop(t){
      requestAnimationFrame(loop);
      if (!last) last = t;
      const dt = Math.min(0.033, (t-last)/1000); // clamp delta for stability
      last = t;

      if (!paused) world.step(fixedTimeStep, dt, 3);

      // sync three <-> cannon
      for (let i=0;i<N;i++){
        threeMeshes[i].position.copy(bodies[i].position);
        threeMeshes[i].quaternion.copy(bodies[i].quaternion);
      }

      controls.update();
      renderer.render(scene, camera);
    }
    loop();
  </script>
</body>
</html>
