<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sketchy Ink — high contrast (material-only)</title>
  <style>
    html,body{height:100%;margin:0;background:#111;overflow:hidden}
    #hud{position:fixed;left:14px;bottom:12px;color:#222;font:12px system-ui;
         background:rgba(255,255,255,.8);border:1px solid #bbb;padding:8px 10px;border-radius:8px}
    canvas{display:block}
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="hud">Orbit + Zoom • High-contrast ink hatch + stipple (no postFX, CSP-safe)</div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    // ----- procedural textures -----
    function canvasTex(draw, w=512, h=w){
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      draw(c.getContext('2d'), w, h);
      const t=new THREE.CanvasTexture(c);
      t.wrapS=t.wrapT=THREE.RepeatWrapping;
      t.minFilter=THREE.LinearMipmapLinearFilter;
      t.magFilter=THREE.LinearFilter;
      t.generateMipmaps=true;
      return t;
    }
    const paperTex = canvasTex((ctx,w,h)=>{
      ctx.fillStyle='#fbfaf5'; ctx.fillRect(0,0,w,h);
      ctx.globalAlpha=0.15; ctx.strokeStyle='#000';
      for(let i=0;i<800;i++){
        const x=Math.random()*w, y=Math.random()*h;
        const len=5+Math.random()*20, a=Math.random()*Math.PI*2;
        ctx.lineWidth=0.3+Math.random()*0.5;
        ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(a)*len, y+Math.sin(a)*len); ctx.stroke();
      }
      const img=ctx.getImageData(0,0,w,h);
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const v=(Math.sin(x*0.25)+Math.sin(y*0.22)+Math.sin((x+y)*0.15))*10;
        img.data[i]+=v; img.data[i+1]+=v; img.data[i+2]+=v;
      }
      ctx.putImageData(img,0,0);
    },1024);
    // 4-row hatch atlas: very light / light / medium / dense
    const hatchTex = canvasTex((ctx,w,h)=>{
      ctx.fillStyle='#fff'; ctx.fillRect(0,0,w,h);
      const rows=4, rowH=h/rows;
      function row(r, step, cross){
        ctx.save(); ctx.translate(0, r*rowH);
        ctx.strokeStyle='#000'; ctx.lineWidth=1.0;
        for(let x=-h; x<w+h; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x+h,h); ctx.stroke(); }
        if(cross){ for(let x=0; x<w+h; x+=step){ ctx.beginPath(); ctx.moveTo(x,h); ctx.lineTo(x-h,0); ctx.stroke(); } }
        ctx.restore();
      }
      row(0,40,false); // very light
      row(1,30,false); // light
      row(2,18,true);  // medium
      row(3,10,true);  // dense
    },1024,4*128);
    // ----- renderer / scene -----
    const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfbfaf5); // paper
    // Paper backdrop
    (()=>{
      const m=new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({map:paperTex}));
      m.position.set(0,0,-20); scene.add(m);
    })();
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(6,5,8);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 0.25));
    const dir = new THREE.DirectionalLight(0xffffff, 0.65);
    dir.position.set(3,4,2); scene.add(dir);
    // ----- ink material (all the look lives here) -----
    const inkMat = new THREE.ShaderMaterial({
      uniforms:{
        hatch:{value:hatchTex},
        paper:{value:paperTex},
        lightDir:{value:new THREE.Vector3(0.4,0.7,0.55).normalize()},
        inkColor:{value:new THREE.Color(0.05,0.05,0.05)}, // darker ink tone
        scale:{value:15.0}, // increased hatch density
        band1:{value:0.78}, // adjusted hatch thresholds
        band2:{value:0.50},
        band3:{value:0.30},
        t1:{value:0.65}, // toon thresholds
        t2:{value:0.90},
        stippleBias:{value:0.70}, // lighter stipple
        rimPow:{value:0.8}, // stronger silhouette
        ambient:{value:0.20}, // slightly lower ambient
        time:{value:0.0}
      },
      vertexShader:/*glsl*/`
        varying vec2 vUv; varying vec3 vN; varying vec3 vWPos; varying vec3 vView;
        void main(){
          vUv = uv;
          vec4 w = modelMatrix*vec4(position,1.0);
          vWPos = w.xyz;
          vN = normalize(normalMatrix*normal);
          vec4 v = viewMatrix*w; vView = normalize(-v.xyz);
          gl_Position = projectionMatrix*v;
        }`,
      fragmentShader:/*glsl*/`
        precision highp float;
        uniform sampler2D hatch, paper;
        uniform vec3 lightDir, inkColor;
        uniform float scale, band1, band2, band3, t1, t2, stippleBias, rimPow, ambient, time;
        varying vec2 vUv; varying vec3 vN; varying vec3 vWPos; varying vec3 vView;
        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
        void main(){
          vec3 N = normalize(vN);
          vec3 L = normalize(lightDir);
          // Half-Lambert with ambient
          float lambert = dot(N,L);
          float halfLambert = lambert*0.5 + 0.5;
          float toneL = clamp(ambient + (1.0-ambient)*halfLambert, 0.0, 1.0);
          // Hatch band select with 4 levels
          float row = toneL>band1 ? 0.0 : (toneL>band2 ? 1.0 : (toneL>band3 ? 2.0 : 3.0));
          float v = (row + 0.5)/4.0;
          // Increased UV jitter for sketchy effect
          vec2 jitter = vec2(hash(floor(vWPos.xy*3.0)+time*0.6),
                             hash(floor(vWPos.zy*3.0)+time*0.6))*0.02;
          vec2 suv = fract(vUv*scale + jitter);
          vec3 hatchRGB = texture2D(hatch, vec2(suv.x, v)).rgb;
          // Quad-tone cut (white / light / mid / black)
          float whiteBand = step(t2, toneL);
          float lightBand = step(0.75, toneL) * (1.0 - whiteBand);
          float midBand = step(t1, toneL) * (1.0 - lightBand - whiteBand);
          float blackBand = 1.0 - whiteBand - lightBand - midBand;
          // Stipple for mid and light bands
          float d = hash(floor(vWPos.xz*40.0));
          float midInk = step(stippleBias, d);
          float lightInk = step(stippleBias + 0.1, d);
          float inkLevel = blackBand + midBand * (1.0 - midInk) + lightBand * (1.0 - lightInk);
          // Stronger rim for sketch outlines
          float rim = pow(1.0 - max(dot(N, vView), 0.0), rimPow);
          rim = smoothstep(0.3, 0.95, rim);
          // Compose with paper texture
          vec3 toon = mix(vec3(1.0), vec3(0.0), inkLevel);
          toon = mix(toon, vec3(0.0), rim);
          vec3 inked = toon * (0.80 + 0.20*hatchRGB);
          inked = mix(inked, inked*inkColor, 0.20);
          vec3 paperRGB = texture2D(paper, vWPos.xz*0.12 + time*0.015).rgb;
          vec3 outc = mix(inked, inked*paperRGB, 0.30);
          gl_FragColor = vec4(outc, 1.0);
        }`
    });
    // ----- geometry using the single ink material -----
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), inkMat);
    ground.rotation.x = -Math.PI/2; scene.add(ground);
    const box = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.5,0.8), inkMat);
    box.position.set(-1.5,0.75,0); box.rotation.y = Math.PI/6; scene.add(box);
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(1.0,36,18), inkMat);
    sphere.position.set(1.5,1.0,0.2); scene.add(sphere);
    const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1.8,12), inkMat);
    cylinder.position.set(0,0.9,-1.2); cylinder.rotation.x = Math.PI/4; scene.add(cylinder);
    const spikes = new THREE.Mesh(new THREE.ConeGeometry(0.3,1.5,8), inkMat);
    spikes.position.set(-0.8,1.5,1.0); spikes.rotation.y = Math.PI/3; scene.add(spikes);
    // Enhanced outlines
    function addOutline(mesh, t=0.065, color=0x000000){
      const o=mesh.clone();
      o.material=new THREE.MeshBasicMaterial({color, side:THREE.BackSide});
      o.scale.multiplyScalar(1+t);
      mesh.add(o);
    }
    addOutline(box); addOutline(sphere); addOutline(cylinder); addOutline(spikes);
    // ----- resize & loop -----
    addEventListener('resize', ()=>{
      const w=innerWidth, h=innerHeight;
      renderer.setSize(w,h);
      camera.aspect=w/h; camera.updateProjectionMatrix();
    });
    renderer.setAnimationLoop((t)=>{
      const time=t/1000;
      inkMat.uniforms.time.value=time;
      box.rotation.y=time*0.5;
      sphere.rotation.x=time*0.3;
      cylinder.rotation.z=time*0.4;
      spikes.rotation.y=time*0.6;
      controls.update();
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
