<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sketchy Ink — high contrast (material-only)</title>
  <style>
    html,body{height:100%;margin:0;background:#111;overflow:hidden}
    #hud{position:fixed;left:14px;bottom:12px;color:#222;font:12px system-ui;
         background:rgba(255,255,255,.8);border:1px solid #bbb;padding:8px 10px;border-radius:8px}
    canvas{display:block}
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="hud">Orbit + Zoom • High-contrast ink hatch + stipple (no postFX, CSP-safe)</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ----- procedural textures -----
    function canvasTex(draw, w=512, h=w){
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      draw(c.getContext('2d'), w, h);
      const t=new THREE.CanvasTexture(c);
      t.wrapS=t.wrapT=THREE.RepeatWrapping;
      t.minFilter=THREE.LinearMipmapLinearFilter;
      t.magFilter=THREE.LinearFilter;
      t.generateMipmaps=true;
      return t;
    }

    const paperTex = canvasTex((ctx,w,h)=>{
      ctx.fillStyle='#fbfaf5'; ctx.fillRect(0,0,w,h);
      ctx.globalAlpha=0.10; ctx.strokeStyle='#000';
      for(let i=0;i<500;i++){
        const x=Math.random()*w, y=Math.random()*h;
        const len=8+Math.random()*30, a=Math.random()*Math.PI*2;
        ctx.lineWidth=0.5+Math.random()*0.6;
        ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(a)*len, y+Math.sin(a)*len); ctx.stroke();
      }
      const img=ctx.getImageData(0,0,w,h);
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const v=(Math.sin(x*0.23)+Math.sin(y*0.21)+Math.sin((x+y)*0.13))*7;
        img.data[i]+=v; img.data[i+1]+=v; img.data[i+2]+=v;
      }
      ctx.putImageData(img,0,0);
    },1024);

    // 3-row hatch atlas: light / medium / dense
    const hatchTex = canvasTex((ctx,w,h)=>{
      ctx.fillStyle='#fff'; ctx.fillRect(0,0,w,h);
      const rows=3, rowH=h/rows;
      function row(r, step, cross){
        ctx.save(); ctx.translate(0, r*rowH);
        ctx.strokeStyle='#000'; ctx.lineWidth=1.2;
        for(let x=-h; x<w+h; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x+h,h); ctx.stroke(); }
        if(cross){ for(let x=0; x<w+h; x+=step){ ctx.beginPath(); ctx.moveTo(x,h); ctx.lineTo(x-h,0); ctx.stroke(); } }
        ctx.restore();
      }
      row(0,32,false);
      row(1,18,true);
      row(2,10,true);
    },1024,3*128);

    // ----- renderer / scene -----
    const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfbfaf5); // paper

    // Paper backdrop
    (()=>{
      const m=new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({map:paperTex}));
      m.position.set(0,0,-20); scene.add(m);
    })();

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(4,3.5,6);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 0.3));
    const dir = new THREE.DirectionalLight(0xffffff, 0.75);
    dir.position.set(2,3,1); scene.add(dir);

    // ----- ink material (all the look lives here) -----
    const inkMat = new THREE.ShaderMaterial({
      uniforms:{
        hatch:{value:hatchTex},
        paper:{value:paperTex},
        lightDir:{value:new THREE.Vector3(0.4,0.7,0.55).normalize()},
        inkColor:{value:new THREE.Color(0.06,0.06,0.06)}, // ink tone
        scale:{value:11.0},      // hatch density
        band1:{value:0.72},      // hatch thresholds
        band2:{value:0.42},
        t1:{value:0.62},         // toon thresholds (↑ → lighter)
        t2:{value:0.88},
        stippleBias:{value:0.66},// ↑ → lighter mids
        rimPow:{value:0.7},      // silhouette strength
        ambient:{value:0.22},    // ambient floor
        time:{value:0.0}
      },
      vertexShader:/*glsl*/`
        varying vec2 vUv; varying vec3 vN; varying vec3 vWPos; varying vec3 vView;
        void main(){
          vUv = uv;
          vec4 w = modelMatrix*vec4(position,1.0);
          vWPos = w.xyz;
          vN = normalize(normalMatrix*normal);
          vec4 v = viewMatrix*w; vView = normalize(-v.xyz);
          gl_Position = projectionMatrix*v;
        }`,
      fragmentShader:/*glsl*/`
        precision highp float;
        uniform sampler2D hatch, paper;
        uniform vec3 lightDir, inkColor;
        uniform float scale, band1, band2, t1, t2, stippleBias, rimPow, ambient, time;
        varying vec2 vUv; varying vec3 vN; varying vec3 vWPos; varying vec3 vView;

        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }

        void main(){
          vec3 N = normalize(vN);
          vec3 L = normalize(lightDir);

          // Half-Lambert with ambient so faces don't crush to black
          float lambert = dot(N,L);
          float halfLambert = lambert*0.5 + 0.5;         // 0..1
          float toneL = clamp(ambient + (1.0-ambient)*halfLambert, 0.0, 1.0);

          // Hatch band select
          float row = toneL>band1 ? 0.0 : (toneL>band2 ? 1.0 : 2.0);
          float v = (row + 0.5)/3.0;

          // Little boil in UVs (object-space, stable)
          vec2 jitter = vec2(hash(floor(vWPos.xy*2.0)+time*0.5),
                             hash(floor(vWPos.zy*2.0)+time*0.5))*0.015;
          vec2 suv = fract(vUv*scale + jitter);
          vec3 hatchRGB = texture2D(hatch, vec2(suv.x, v)).rgb; // white bg, black lines

          // Tri-tone cut (white / mid / black)
          float whiteBand = step(t2, toneL);
          float blackBand = 1.0 - step(t1, toneL);
          float midBand   = 1.0 - whiteBand - blackBand;

          // Stipple only the mid band (dot pattern)
          float d = hash(floor(vWPos.xz*32.0));   // 0..1
          float midInk = step(stippleBias, d);    // 1→white, 0→black
          float inkLevel = blackBand + midBand * (1.0 - midInk);

          // Silhouette rim (brighter where view ⟂ normal, then turned into ink)
          float rim = pow(1.0 - max(dot(N, vView), 0.0), rimPow);
          rim = smoothstep(0.35, 0.9, rim);

          // Compose: start from paper white, add toon ink, add rim, then multiply by hatch
          vec3 toon = mix(vec3(1.0), vec3(0.0), inkLevel);   // paper→black
          toon = mix(toon, vec3(0.0), rim);                  // add rim as black
          // hatchRGB is 1 on paper, ~0 on lines → keep tone but carve pen lines
          vec3 inked = toon * (0.85 + 0.15*hatchRGB);        // keep lines dark without over-blackening
          // tint toward inkColor slightly
          inked = mix(inked, inked*inkColor, 0.15);

          // Subtle paper fiber modulation in world space
          vec3 paperRGB = texture2D(paper, vWPos.xz*0.1 + time*0.01).rgb;
          vec3 outc = mix(inked, inked*paperRGB, 0.25);

          gl_FragColor = vec4(outc, 1.0);
        }`
    });

    // ----- geometry using the single ink material -----
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), inkMat);
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    const box = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), inkMat);
    box.position.set(-1.2,0.5,0); scene.add(box);

    const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.9,48,24), inkMat);
    sphere.position.set(1.3,0.9,0.5); scene.add(sphere);

    // subtle outlines (inverted hull)
    function addOutline(mesh, t=0.055, color=0x000000){
      const o=mesh.clone();
      o.material=new THREE.MeshBasicMaterial({color, side:THREE.BackSide});
      o.scale.multiplyScalar(1+t);
      mesh.add(o);
    }
    addOutline(box); addOutline(sphere);

    // ----- resize & loop -----
    addEventListener('resize', ()=>{
      const w=innerWidth, h=innerHeight;
      renderer.setSize(w,h);
      camera.aspect=w/h; camera.updateProjectionMatrix();
    });

    renderer.setAnimationLoop((t)=>{
      const time=t/1000;
      inkMat.uniforms.time.value=time;
      box.rotation.y=time*0.6;
      sphere.rotation.x=time*0.4;
      controls.update();
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
